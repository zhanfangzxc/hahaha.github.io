title: 优秀文章整理
date: 2015-10-23 16:54:03
tags:
- Android
- 文章

---

### Handler相关

**Handler消息机制**:[http://codecloud.net/android-handler-6351.html](http://codecloud.net/android-handler-6351.html)

### Handler消息机制简介

- Handler 处理消息；发送消息，并将消息压入栈中
- Lopper  通过loop()函数中的死循环，不断的从MessageQueue中取出Message，然后传给Handler进行处理。
- MessageQueue 消息队列，用来存储Runnable、Message

### 为什么在主线程中能够直接创建Handler

在ActivityThread.class的**main()**函数中，能够看到如下两句代码：

	Lopper.prepareMainLopper();

	Lopper.loop();
	
### 在子线程创建Handler的步骤

1. Lopper.prepare();
2. 实例化Handler，在构造方法中实现handleMessage(Message msg)处理消息;
3. Lopper.loop();

第一步源码：

	public class Lopper{
		...
		private static final ThreadLocal sThreadLocal = new ThreadLocal();
		
		final MessageQueue mQueue;
		
		......
		
		public static final void prepare(){
			if(sThreadLocal.get() != null){
				throw new RuntimeException("Only one Lopper may be created per thread");
			}
			//创建一个Looper对象，并绑定到ThreadLocal中
			//为了保证每一个调用prepare()函数的线程里面都有一个唯一的Looper对象
			//在创建Looper的同时也创建了一个MessageQueue对象
			sThreadLocal.set(new Lopper());
		}
		
		public static final void prepareMainLopper(){
			prepare();
			setMainLooper(myLooper());
			if(Process.supportProcesses()){
				myLooper().mQueue.mQuitAllowed = false;
			}
		}
		
		private synchronized static void setMainLooper(Looper looper){
			sMainLooper = Looper;
		}
		
		public static final Looper myLooper(){
			return (Looper)sThreadLocal.get();
		}
		
		private Looper(){
			mQueue = new MessageQueue();
			mRun = true;
			mThread = Thread.currentThread();
		}
	}
	
第二步：创建Handler实例

	Handler handler = new Handler(){
		public void handleMessage(Message msg){
			//处理消息逻辑
		}
	};
	
	//Handler的构造函数
	public Handler();
	public Handler(Callback callback);
	public Handler(Looper looper);
	public Handler(Looper looper,Callback callback);
	
	//源码
	
	public Handler(Callback callback,boolean async){
		mLooper = Looper.myLooper();
		if(myLooper == null){
			throw new RuntimeException("XXX");
		}
		mQueue = mLooper.mQueue;
		mCallback = callback;
		mAsynchronous = async;
	}
	
> 在创建Handler之前必须先有一个Looper，在创建Looper的同时会创建一个MessageQueue对象，所以在Handler的构造函数中能够同时获取Looper和MessageQueue这两个对象。

第三步Lopper.loop()的源码：

	public static void loop(){
		final Looper me = myLooper();
		final MessageQueue queue = me.mQueue;
		
		for(;;){
			Message msg = queue.next();
			if(msg == null){
				return;
			}
			...
			//关键代码
			msg.target.dispatchMessage(msg);
		}
	}
	
接下来看**dispatch(msg)**方法的源码

	public void dispatchMessage(Message msg){
		if(msg.callback != null){
			handleCallback(msg);
		}else{
			if(mCallback != null){
				if(mCallback.handleMessage(msg)){
					return;
				}
			}
			//这个即是我们每次创建Handler的时候需要实现的方法
			handleMessage(msg);
		}
	}

### 发送消息

> 我们一般发送消息通过sendMessage(msg),下面是发送消息的源码：

	public boolean sendMessageAtTime(Message msg,long uptimeMillis){
		MessageQueue queue = mQueue;
		if(queue == null){
			RuntimeException e = new RuntimeException("XXX");
			return false;
		}
		//将Message压入MessageQueue中
		return enqueueMessage(queue,mag,uptimeMillis);
	}