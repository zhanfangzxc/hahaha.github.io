title: 代码片段
date: 2015-10-08 13:47:59
categories: Android
tags:
- Android
- code

---

### 手机号中自动添加"-"

为Edittext添加监听方法

	edittext.addTextChangedListener(new TextWatcher());
		
TextWatcher接口如下:

	public interface TextWatcher extends NoCopySpan{
	
		//在字符串s被，从索引start(包含)的字符开始的count个字符，将被长度为after的新文本代替。
		public void beforeTextChanged(CharSequence s,int start,int count, int after);
		
		//在字符串s内，从索引start(包含)的字符开始count个字符刚刚替换了长度为before的旧字符。
		public void onTextChanged(CharSequence s, int start, int before, int count);
		
		//字符串s内容已经发生了变化
		public void afterTextChanged(Editable s);
	}

具体操作:

	public void onTextChanged(CharSequence s,int start,int before, int count){
		if(count == 1){
			int length = s.toString().length();
			if(length == 3 || length == 8){
				editText.setText(s + "-");
				editText.setSelection(editText.getText().toString().length());
			}
		}
	}
		
### Handler的优化

在Android应用启动时，framework会为该应用程序的主线程创建一个Lopper对象，这个Lopper对象包含一个简单的消息队列，并且能够循环处理队列中的消息。主线程的Lopper对象会被碎该应用程序的整个生命周期。

造成内存泄漏的原因：只要有未处理的消息，那么该消息就会引用Handler，非静态的Handler又会引用外部类，即Activity，导致Activity无法被回收，造成泄漏。

**静态内部类不会持有对外部类的引用**

解决方案：

	public class SampleActivity extends Activity{

		private static class MyHandler extends Handler{
			private final WeakReference<SampleActivity> mActivity;
			
			public MyHandler(SampleActivity activity){
				mActivity = new WeakReference<SampleActivity>(activity);
			}
			
			@Override
			public void handleMessage(Message msg){
				SampleActivity activity = mActivity.get();
				if(activity != null){
					//...
				}
			}
		}
		
		private final MyHandler mHandler = new MyHandler(this);
		
		private static final Runnable sRunnable = new Runnable(){
			@Override
			public void run(){
			
			}
		}
		
		@Override
		protected void onCreate(Bundle savedInstanceState){
			super.onCreate(savedInstanceState);
			
			mHandler.postDelayed(sRunnable,1000*60*10);
			
			finish();
		}
	}
	
### 实现对隐式Intent的运行时检查

如果想打开相机或者发送图片等隐式Intent，比如说打开相机， 如果手机中不存在相机的话，那么系统就会抛出**ActivityNotFoundException**,如果不做处理的话，程序就会崩溃。所以具体的解决方案是，在使用隐式Intent的时候，首先进行检查，代码如下：

	Intent intent = new Intent(Intent.Action_XXX);
	ComponentName componentName = intent.resolveActivity(getPacakgeManager());
	if(componentName != null){
		String className = component.getClassName();
	}
	
### 使用NotificationCompat兼容包来处理消息通知

	NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
	builder.setSmallIcon(R.drawable.notification_icon);
	String text = "aaaaa";
	builder.setContentText(text);

	//添加点击效果
	PendingIntent intent = XXX;
	builder.setContentIntent(intent);

	int color = getResources().getColor(R.color.black);
	builder.setColor(color);

	//设置图片
	Bitmap bitmap = ...;
	builder.setLargeIcon(bitmap);

	//设置样式
	builder.setStyle(new NotificationCompat.bigTextStyle(text));

	PendingIntent intent =...;
	builder.addAction(mew NotificationCompat.Action(R.drawable.icon,"Mute",intent));

	//设置穿戴设备的样式
	NotificationCompat.WearableExtender wearableExtender = new NotificationCompat.WearableExtender();
	RemoteInput remoteInput = new RemoteInput.Builder("voice_result_key").setLabel("Reply").build();

	wearableExtender.addAction(new NotificationCompat.Action.Builder(R.drawable.mute_icon,"Reply",replyIntent).addRemoteInout(remoteInput).build);
	builder.extend(wearableExtender);

	Notification notification = builder.build();
	NotificationManagerCompat.from(this).notify(0,notification);
	
### 使用Toobar代替ActionBar

第一步：改变主题为**Theme.AppCompat.NoActionBar**

第二步：修改布局文件

	<android.support.v7.widget.Toolbar
		android:id="@+id/id_toolbar"
		android:layout_width="match_parent"
		android:layout_height＝"wrap_content"
		android:layout_alignParentTop="true"
		android:minHeight="?attr.actionBarSize">
	</android.support.v7.widget.Toolbar>

第三步：修改代码

	@Override
	protected void onCreate(Bundle savedInstanceState){
		setContentView(R.layout.activity_main);
		Toolbar toolbar = findviewById(R.id.toolbar_layout);
		setSupportActionBar(toolbar);
	}

### 参考文章

1. [Android开发最佳实践](http://hukai.me/android-dev-patterns/)