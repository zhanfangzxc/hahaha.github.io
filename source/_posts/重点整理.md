title: 重点整理
date: 2015-12-28 11:59:45
tags:
- Android

---
### 如何选择compileSdkVersion,minSdkVersion,targetSdkVersion

用较低的minSdkVersion来覆盖最大的人群，用最新的SDK设置Target和compile来活的最好的外观和行为。

### 退出应用的方式
原文地址:[http://android.jobbole.com/82316/](http://android.jobbole.com/82316/)

- 容器式:建立一个容器，将所有的Activity存储起来，退出时循环遍历finish所有的Activity，但是当Activity异常退出的时候，容器并不会立即释放掉对activity的引用，就会导致内存问题
- 广播式：在BaseActivity中注册一个广播，退出时发送一个广播，finish退出。

		public class BaseActivity extends Activity{
			private static final String EXITACTION="action.exit";
			private ExitReceiver exitReceiver = new ExitReceiver();
			@Override
			protected void onCreate(Bundle savedInstanceState){
				super.onCreate(savedInstanceState);
				IntentFilter filter = new IntentFilter();
				filter.addAction(EXITACTION);
				registerReceiver(exitReceiver,filter);
			}
			
			@Override
			protected void onDestroy(){
				super.onDestroy();
				unregisterReceiver(exitReceiver);
			}
			
			class ExitReceiver extends BroadcastReceiver{
				@Override
				public void onReceive(Context context,Intent intent){
					BaseActivity.this.finish();
				}
			}
		}

- 进程式:通过直接杀死当前应用的进程来结束应用

		android.os.Process.killProcess(android.os.Process.myPid());
		System.exit(0);
		ActivityManager manager = (ActivityManager)getSystemService(ACTIVITY_SERVICE);
		manager.killBackgroundProcesses(getPackageName());

- RS优雅式：Receiver+singleTask
	
	- 第一步：在HomeActivity注册一个退出广播，和第二个广播式一样，但是这里只需要在HomeActivity一个页面注册即可。
	- 第二步：设置HomeActivity的启动模式为singleTask

当需要退出的时候只需要startActivity(this,HomeActivity.class);,再发送一个退出广播，上面的代码首先会把栈中HomeActivity之上的所有Activity移除出栈，然后接到广播finish自己。

### 自定义View继承默认的OnMeasure函数

- 如果自定义View设置为match_parent或者wrap_content没有任何区别，其显示大小由控件决定，他会填满整个父控件的空间。
- 如果大小设置为固定的值，那么其显示为大小固定的值。

### 正确自定义Application的方法

	public class MyApplication extends Application{
		private static MyApplication app;
		
		public static MyApplication getInstance(){
			return app;
		}
		
		@Override
		public void onCreate(){
			super.onCreate();
			app = this;
		}
	}
	
### View的绘制流程

#### onMeasure()

**measure(int widthMeasureSpec,int heightMeasureSpec)**:两个参数用来确定视图的宽度和高度的规格和大小。

**MeasureSpec**的值由specSize和specMode共同组成，其中specSize记录的是大小，specMode记录的是规格；specMode有以下三种类型：

1. EXACTLY

表示父试图希望子试图的大小应该有specSize的值来决定，系统默认会按照这个规则来设置子试图的大小。

2. AT_MOST

表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小的去设置这个视图，并且保证不会超过specSize，系统默认会按照这个规则来设置子视图的大小。

3. UNSPECIFIED

开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。

通常情况下这两个参数都是由父视图经过计算后传递给子视图的，说明父视图会在一定程度上决定子视图的大小，那么根视图的widthMeasureSpec和heightMeasureSpec是从何而来的呢：

	//ViewRoot中的performTraversals()方法
	
	childWidthMeasureSpec = getRootMeasureSpec(diresdWindowWidth,lp.width);
	childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight,lp.height);
	
#### onLayout()

getWidth()和getMeasureWidth()方法的区别？

getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法是要在layout()过程结束后才能获取到。另外getMeasuredWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值是通过视图右边的坐标减去左边的坐标计算出来的。