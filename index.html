<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="既然选择远方，便只顾风雨兼程" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="ZhaoShanShan’s Blog" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="既然选择远方，便只顾风雨兼程">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhaoShanShan’s Blog">
<meta property="og:url" content="http://zhaoshanshan.me/index.html">
<meta property="og:site_name" content="ZhaoShanShan’s Blog">
<meta property="og:description" content="既然选择远方，便只顾风雨兼程">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhaoShanShan’s Blog">
<meta name="twitter:description" content="既然选择远方，便只顾风雨兼程">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'always'
  };
</script>

  <title> ZhaoShanShan’s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">ZhaoShanShan’s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/03/29/Cursor-CursorAdapter-以及ContentProvider之间的爱恨纠缠/" itemprop="url">
                Cursor CursorAdapter 以及ContentProvider之间的爱恨纠缠
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-03-29T16:38:21+08:00" content="2016-03-29">
            2016-03-29
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/03/29/Cursor-CursorAdapter-以及ContentProvider之间的爱恨纠缠/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/29/Cursor-CursorAdapter-以及ContentProvider之间的爱恨纠缠/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="题外话">题外话</h4><p>工作了两年，用了太多的开源库，现在回头才发现，自己已经把基础都快丢干净了，甚是羞愧，这段时间为了帮助我弟学习安卓，自己也准备慢慢把这些重要的知识都给捡回来，要不自己真的要被淘汰了。</p>
<h4 id="进入正题">进入正题</h4><p>我们一般在写ContentProvider的时候，我们会在query中添加如下代码</p>
<pre><code><span class="keyword">if</span>(<span class="built_in">cursor</span>!=<span class="keyword">null</span>){
    <span class="built_in">cursor</span>.setNotificationUri(getContext().getContentResolver(),url);
}
</code></pre><p>现在通过源码，我们看看setNotificationUri方法做了什么</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setNotificationUri</span><span class="params">(ContentResolver cr, Uri notifyUri, <span class="keyword">int</span> userHandle)</span> </span>{
      <span class="keyword">synchronized</span> (mSelfObserverLock) {
          mNotifyUri = notifyUri;
          mContentResolver = cr;
          <span class="keyword">if</span> (mSelfObserver != <span class="keyword">null</span>) {
          <span class="comment">//如果mSelfObserver不为空的情况下，就取消注册</span>
         mContentResolver.unregisterContentObserver(mSelfObserver);
          }
          <span class="comment">//然后创建个新的SelfContentObserver</span>
          mSelfObserver = <span class="keyword">new</span> SelfContentObserver(<span class="keyword">this</span>);
          <span class="comment">//重新注册</span>
mContentResolver.registerContentObserver(mNotifyUri, <span class="keyword">true</span>, mSelfObserver, userHandle);
          mSelfObserverRegistered = <span class="keyword">true</span>;
      }
  }
</code></pre><p>在ContentProvider中的delete、update、insert方法中，我们会添加如下代码：</p>
<pre><code><span class="keyword">if</span>(affectedRow &gt; <span class="number">0</span>){
    getContext<span class="literal">()</span>.getContentResolver<span class="literal">()</span>.notifyChange(uri,null);
}
</code></pre><p>notifyChange方法主要是用来通知所有的观察者数据库改变了，默认情况下CursorAdapter实例是可以收到这个通知的。<br>此时当数据库改变的时候，AbstractCursor中的mSelfObserver中的onChange方法就会执行，下面看一下源码:</p>
<pre><code>@Override
   <span class="keyword">public</span> <span class="keyword">void</span> onChange(<span class="built_in">boolean</span> selfChange) {
       AbstractCursor <span class="built_in">cursor</span> = mCursor.<span class="built_in">get</span>();
       <span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span>) {
           <span class="built_in">cursor</span>.onChange(<span class="keyword">false</span>);
       }
   }
</code></pre><p>接着就会执行Cursor的onChange方法：</p>
<pre><code><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>{
    <span class="keyword">synchronized</span> (mSelfObserverLock) {
    <span class="comment">//此处调用了dispatchChange方法</span>
        mContentObservable.dispatchChange(selfChange, <span class="keyword">null</span>);
        <span class="keyword">if</span> (mNotifyUri != <span class="keyword">null</span> &amp;&amp; selfChange) {
            mContentResolver.notifyChange(mNotifyUri, mSelfObserver);
        }
    }
}
</code></pre><p>在ContentObservable方法中的dispatchChange方法中调用了所有的ContentObserver的dispatchChange方法，其中就包含在CursorAdapter中注册的ChangeObserver，看ContentObserver的源码可以看到，此处接着会去调用onChange方法，也就是会去调用ChangeObserver的onChange方法。也就是下面所说的onContentChanged()方法。</p>
<h4 id="Cursor和CursorAdapter的关系">Cursor和CursorAdapter的关系</h4><p>在CursorAdapter的构造函数中需要传入一个Cursor对象，然后构造函数会调用init方法，该方法的源码如下：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, Cursor c, <span class="keyword">int</span> flags)</span> </span>{
    <span class="keyword">if</span> ((flags &amp; FLAG_AUTO_REQUERY) == FLAG_AUTO_REQUERY) {
        flags |= FLAG_REGISTER_CONTENT_OBSERVER;
        mAutoRequery = <span class="keyword">true</span>;
    } <span class="keyword">else</span> {
        mAutoRequery = <span class="keyword">false</span>;
    }
    <span class="keyword">boolean</span> cursorPresent = c != <span class="keyword">null</span>;
    mCursor = c;
    mDataValid = cursorPresent;
    mContext = context;
    mRowIDColumn = cursorPresent ? c.getColumnIndexOrThrow(<span class="string">"_id"</span>) : -1;
    <span class="keyword">if</span> ((flags &amp; FLAG_REGISTER_CONTENT_OBSERVER) == FLAG_REGISTER_CONTENT_OBSERVER) {
   <span class="comment">//此处创建两个ContentObserver</span>
        mChangeObserver = <span class="keyword">new</span> ChangeObserver();
        mDataSetObserver = <span class="keyword">new</span> MyDataSetObserver();
    } <span class="keyword">else</span> {
        mChangeObserver = <span class="keyword">null</span>;
        mDataSetObserver = <span class="keyword">null</span>;
    }

    <span class="keyword">if</span> (cursorPresent) {
        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) c.registerContentObserver(mChangeObserver);
        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) c.registerDataSetObserver(mDataSetObserver);
    }
}
</code></pre><p>init方法中会创建两个ContentObserver,一个是ChangeObserver，一个是DataSetObserver,并且通过Cursor注册这两个观察者，如果获取到改变的时候，就会分别调用这两个Observer的onChange方法:</p>
<pre><code> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="title">ChangeObserver</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>(<span class="keyword">new</span> Handler());
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deliverSelfNotifications</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>{
        onContentChanged();
    }
}
</code></pre><p> 也就是执行onContentChanged()方法，现在来看看这个方法的源码：</p>
<pre><code> <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onContentChanged</span><span class="params">()</span> </span>{
     <span class="comment">//如果设置了自动重新查询的话</span>
    <span class="keyword">if</span> (mAutoRequery &amp;&amp; mCursor != <span class="keyword">null</span> &amp;&amp; !mCursor.isClosed()) {
        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"Cursor"</span>, <span class="string">"Auto requerying "</span> + mCursor + <span class="string">" due to update"</span>);
        <span class="comment">//此时Cursor就会重新查询数据</span>
        mDataValid = mCursor.requery();
    }
}
</code></pre><p>此处虽然是重新查询了，但是没有notifyDataSetChange，所以list怎么刷新的呢，接着看一下Cursor中的requery方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">requery</span><span class="params">()</span> </span>{  
    <span class="keyword">if</span> (mSelfObserver != <span class="keyword">null</span> &amp;&amp; mSelfObserverRegistered == <span class="keyword">false</span>) {  
        mContentResolver.registerContentObserver(mNotifyUri, <span class="keyword">true</span>, mSelfObserver);  
        mSelfObserverRegistered = <span class="keyword">true</span>;  
    }  
    <span class="comment">//此处DataSetObservable收到变化的时候，就会调用他自己的onChanged方法</span>
    mDataSetObservable.notifyChanged();  
    <span class="keyword">return</span> <span class="keyword">true</span>;  
</code></pre><p>}  </p>
<p>在他的onChanged方法中：</p>
<pre><code> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSetObserver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DataSetObserver</span> {</span>
    <span class="annotation">@Override</span>
    public void onChanged() {
        mDataValid = <span class="literal">true</span>;
        <span class="comment">//就是这个了</span>
        notifyDataSetChanged();
    }

    <span class="annotation">@Override</span>
    public void onInvalidated() {
        mDataValid = <span class="literal">false</span>;
        notifyDataSetInvalidated();
    }
}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/29/View事件的分发机制/" itemprop="url">
                View事件的分发机制
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-02-29T15:35:26+08:00" content="2016-02-29">
            2016-02-29
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/29/View事件的分发机制/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/29/View事件的分发机制/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="点击事件的传递规则">点击事件的传递规则</h3><p>点击事件的分发过程有三个很重要的方法来共同完成，<strong>dispatchTouchEvent()</strong>、<strong>onInterceptTouchEvent()</strong>、<strong>onTouchEvent()</strong>.</p>
<ul>
<li>public boolean dispatchTouchEvent(MotionEvent ev)</li>
</ul>
<p>用来进行事件的分发，如果事件能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</p>
<ul>
<li>public boolean onInterceptTouchEvent(MotionEvent ev)</li>
</ul>
<p>用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么再同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
<ul>
<li>public boolean onTouchEvent(MotionEvent event)</li>
</ul>
<p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。</p>
<h3 id="传递机制">传递机制</h3><p>对于一个根View来说，点击事件产生后，他的dispatchEvent方法会被调用，如果该ViewGroup的onInterceptTouchEvent返回true，就表示要拦截该事件，接着就交给ViewGroup的onTouchEvent方法处理，如果onInterceptTouchEvent返回false,这个事件就会传递给子元素，接着子元素的dispatchTouchEvent就会被调用。</p>
<p>如果一个View需要处理事件的时候，当他设置了onTouchListener,那么onTouchListener的onTouch方法会被调用，这时事件的处理要看onTouch的返回值，返回true，onTouchEvent将不会被调用，返回false，当前view的onTouchEvent会被调用，所以onTouchListener优先级比onTouchEvent要高，而OnClickListener优先级最低。</p>
<ul>
<li><p>点击事件传递过程：Activity -&gt; Window -&gt; View</p>
</li>
<li><p>requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/26/管理ViewGroup中的触摸事件/" itemprop="url">
                管理ViewGroup中的触摸事件
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-02-26T10:09:59+08:00" content="2016-02-26">
            2016-02-26
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/26/管理ViewGroup中的触摸事件/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/26/管理ViewGroup中的触摸事件/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>处理<strong>ViewGroup</strong>中的触摸时间值得注意的是，因为ViewGroup本身与带有子View的ViewGroup的触摸事件是不同的。为了确保每个View都能正确的接收到触摸事件，需要覆盖<strong>onInterceptTouchEvent()</strong>方法</p>
<h3 id="ViewGroup拦截触摸事件">ViewGroup拦截触摸事件</h3><p>onInterceptTouchEvent()方法在ViewGroup表面或者它的子View的表面检测到触摸事件的时候会被调用。如果onInterceptTouchEvent返回true，<strong>MotionEvent</strong>会被拦截，意味着该事件将不会传递到子view，但是会到达父View的<strong>onTouchEvent()</strong>.</p>
<p>onInterceptTouchEvent方法给父View一个提前看到任何触摸事件的机会，如果你在onInterceptTouchEvent()中返回了true，在子视图处理触摸事件的时候将会接受到一个<strong>ACTION_CANCEL</strong>，然后之后的时间将会直接被发送到父view进行处理。onInterceptTouchEvent()也可以返回false，用来监视在视图层次中触摸事件的传递以及自己的onTouchEvent方法中如何处理触摸事件。</p>
<p>在以下的代码片段中，MyViewGroup类继承ViewGroup，MyViewGroup包含多个子视图，如果你用手指拖过一个水平子视图，子view将不再接收到触摸事件，MyViewGroup将会处理触摸事件通过滚动其内容，如果在子view中点击了按钮，或者垂直滚动子view，父view将不会再拦截他们的触摸事件，因为子view是目标，在这种情况下，onInterceptTouchEvent会返回false，并且MyViewGroup的onTouchEvent()将不会被调用。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewGroup</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span></span>{
    <span class="keyword">private</span> <span class="keyword">int</span> mTouchSlop;

    ...

    ViewConfiguration vc = ViewConfiguration.get(view.getContext());
    mTouchSlop = vc.getScaledTouchSlop();
    ...

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span>{
         <span class="comment">/*
     * This method JUST determines whether we want to intercept the motion.
     * If we return true, onTouchEvent will be called and we do the actual
     * scrolling there.
     */</span>

        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);

        <span class="keyword">if</span>(action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP){
            mIsScrolling = <span class="keyword">false</span>;
            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不拦截触摸事件，让子view处理</span>
        }

        <span class="keyword">switch</span>(action){
            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:
                <span class="keyword">if</span>(mIsScrolling){
                    <span class="comment">//正在滚动，所以拦截触摸事件</span>
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                }

                <span class="comment">//如果用户手指水平拖动的距离大于touch slop，开始滚动</span>
                <span class="keyword">final</span> <span class="keyword">int</span> xDiff = calculateDistanceX(ex);

                <span class="comment">//使用ViewConfiguration常量来计算Touch slop</span>
                <span class="keyword">if</span>(xDiff &gt; mTouchSlop){
                    mIsScrolling = <span class="keyword">true</span>;
                    <span class="keyword">return</span> <span class="keyword">false</span>;
                }
                <span class="keyword">break</span>;
        }
        ...
    }
    <span class="comment">//通常，我们不希望拦截触摸事件，应该被子view处理</span>
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span></span>{
    <span class="comment">//这里是处理触摸事件的地方</span>
    <span class="comment">//这个方法只有当触摸事件在onInterceptTouchEvent中被拦截的时候才会被调用。</span>
}
}
</code></pre><h3 id="使用ViewConfiguration_常量">使用ViewConfiguration 常量</h3><p>上面的代码片段使用<strong>ViewConfiguraion</strong>初始化了一个mTouchSlop变量，你可以使用ViewConfiguration类访问Android系统中常用的距离，速度等常量。</p>
<p>Touch Slop通常用于防止当用于执行一些其他的触摸操作，比如触摸屏幕元素造成的意外滚动。</p>
<p>另外两个常用的ViewConfiguration中的方法是<strong>getScaledMinimumFlingVelocity()</strong>和<strong>getScaledMaximumFlingVelocity()</strong>.这两个方法返回fling的说以后的最大最小速度，以像素每秒为单位，比如：</p>
<pre><code>ViewConfiguration vc = ViewConfiguration.get(view.getContext());
<span class="keyword">private</span> <span class="keyword">int</span> mSlop = vc.getScaledTouchSlop();
<span class="keyword">private</span> <span class="keyword">int</span> mMinFlingVelocity = vc.getScaledMinmumFlingVelocity();
<span class="keyword">private</span> <span class="keyword">int</span> mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();

...

<span class="keyword">case</span> MotionEvent.ACTION_MOVE:
    ...
    <span class="keyword">float</span> deltaX = motionEvent.getRawX() - mDownX;
    <span class="keyword">if</span>(Math.abs(deltaX) &gt; mSlop){
        <span class="comment">//发生滑动</span>
    }

...

<span class="keyword">case</span> MotionEvent.ACTION_UP:
    ...
    <span class="keyword">if</span>(mMinFlingVelocity &lt;= velocityX &amp;&amp; velocityX &lt;= mMaxFlingVelocity &amp;&amp; velocityY &lt; velocityX){

    }
</code></pre><h3 id="扩展子视图的可触摸区域">扩展子视图的可触摸区域</h3><p>Android提供了一个<strong>TouchDelegate</strong>类来使父view在子view的界限之上扩展子view。这是非常有用的，当子view小的时候，应该有一个大的可接触区域，如果需要的话也可以使用这个方法来缩小子view的接触区域。</p>
<p>在下面的例子中，ImageButton作为delegate view(将被父view扩展触摸区域的view)，下面是布局文件：</p>
<pre><code><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/parent_layout"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">ImageButton</span> <span class="attribute">android:id</span>=<span class="value">"@+id/button"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:background</span>=<span class="value">"@null"</span>
        <span class="attribute">android:src</span>=<span class="value">"@drawable/icon"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span>
</code></pre><p>以下的代码片段如下：</p>
<ul>
<li>获取父view并且再ui线程中发送一个Runnable，确保再在调用<strong>getHitRect()</strong>方法之前父view能够布局好子view，getHitRect()方法获取子view在父view坐标中的矩形区域。</li>
<li>找到子view ImageButton，并且调用getHitRect()方法来获取子view的可触摸区域的边界。</li>
<li>扩展ImageButton矩形边界的区域。</li>
<li>实例化一个TouchDelegate,通过扩大矩形和ImageButton的子view作为参数</li>
<li>设置父视图TouchDelegate</li>
</ul>
<p>如果触摸事件发生再子view的课触摸矩形中，父view将会将触摸事件传给子view并且由子view来处理。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span>{</span>

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstance){
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="comment">//获取父view</span>
        <span class="type">View</span> parentView = findViewById(<span class="type">R</span>.id.parent_layout);

        parentView.post(<span class="keyword">new</span> <span class="type">Runnable</span>(){
            <span class="annotation">@Override</span>
            public void run(){
                <span class="type">Rect</span> delegateArea = <span class="keyword">new</span> <span class="type">Rect</span>();
                <span class="type">ImageButton</span> myButton = (<span class="type">ImageButton</span>)findViewById(<span class="type">R</span>.id.button);
                myButton.setEnabled(<span class="literal">true</span>);
                myButton.setOnclickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>(){
                    <span class="type">Toast</span>.makeText(<span class="type">MainActivity</span>.<span class="keyword">this</span>,<span class="string">"Touch occured within ImageButton touch region."</span>,<span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();
                });
            }
        });

        myButton.getHitRect(delegateArea);

        delegateArea.right += <span class="number">100</span>;
        delegateArea.bottom += <span class="number">100</span>;

        <span class="type">TouchDelegate</span> touchDelegate = <span class="keyword">new</span> <span class="type">TouchDelegate</span>(delegateArea,myButton);

        <span class="keyword">if</span>(<span class="type">View</span>.<span class="keyword">class</span>.isInstance(myButton.getParent)){
            ((<span class="type">View</span>)myButton.getParent()).setTouchDelegate(touchDelegate);
        }

    }
}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/25/为初学者整理/" itemprop="url">
                为初学者整理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-02-25T16:21:48+08:00" content="2016-02-25">
            2016-02-25
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/25/为初学者整理/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/25/为初学者整理/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="Activity相关">Activity相关</h3><h4 id="1、爱她就要了解他之Activity">1、爱她就要了解他之Activity</h4><p><a href="http://www.imooc.com/article/4497" target="_blank" rel="external">http://www.imooc.com/article/4497</a></p>
<ul>
<li>Activity的生命周期</li>
<li>Activity的启动方式</li>
<li>启动常见的系统Activity</li>
<li>Activity之间传递数据等</li>
</ul>
<h4 id="关于获取当前Activity的一些思考">关于获取当前Activity的一些思考</h4><p><a href="http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android/" target="_blank" rel="external">http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android/</a></p>
<ul>
<li>通过使用反射获取Activity</li>
</ul>
<h3 id="View相关">View相关</h3><h4 id="1、了解Android的LayoutInflater-inflate()">1、了解Android的LayoutInflater.inflate()</h4><p><strong>原文</strong>:<a href="http://www.imooc.com/article/4497" target="_blank" rel="external">http://www.imooc.com/article/4497</a></p>
<p><strong>翻译</strong>:<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0225/3992.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0225/3992.html</a></p>
<ul>
<li>LayoutInflater.inflate(布局文件,根布局,是否添加根布局)</li>
<li>LayoutInflater.inflate(布局文件,根布局);等同于上面的方法</li>
<li>最后一个参数的使用场景，以及设置true/false的时候布局的结构</li>
<li>RecyclerView以及Fragment中为什么要把最后一个参数设置成false</li>
<li>如果使用两个参数的方法，同时将根布局参数设置成<strong>null</strong>的使用场景</li>
</ul>
<h4 id="RecyclerView介绍">RecyclerView介绍</h4><p><a href="http://www.jianshu.com/p/16712681731e" target="_blank" rel="external">http://www.jianshu.com/p/16712681731e</a></p>
<p><strong>使用RecyclerView实现联系人列表</strong>:<a href="https://github.com/jiang111/IndexRecyclerView" target="_blank" rel="external">https://github.com/jiang111/IndexRecyclerView</a></p>
<h3 id="完整项目">完整项目</h3><p><strong>新闻客户端</strong>:<a href="https://github.com/oubowu/OuNews.git" target="_blank" rel="external">https://github.com/oubowu/OuNews.git</a></p>
<p><strong>MVP架构的知乎客户端</strong>:<a href="https://github.com/fangx/ZhiHuMVP" target="_blank" rel="external">https://github.com/fangx/ZhiHuMVP</a></p>
<p><a href="https://github.com/oxoooo/mr-mantou-android" target="_blank" rel="external">https://github.com/oxoooo/mr-mantou-android</a></p>
<h3 id="WebView相关">WebView相关</h3><p><strong>WebView与Javascript相互调用</strong>:<a href="http://mthli.github.io/Android-WebView-JavaScript" target="_blank" rel="external">http://mthli.github.io/Android-WebView-JavaScript</a></p>
<p>###　内存管理</p>
<p><strong>Android内存管理机制</strong>:<a href="http://www.jianshu.com/p/56c7cda86ad3" target="_blank" rel="external">http://www.jianshu.com/p/56c7cda86ad3</a></p>
<p><strong>避免内存泄漏</strong>:<a href="http://www.cnblogs.com/JohnTsai/p/5256295.html" target="_blank" rel="external">http://www.cnblogs.com/JohnTsai/p/5256295.html</a></p>
<h3 id="RxJava">RxJava</h3><p><strong>RxJava学习</strong>:<a href="https://github.com/jiang111/RxJavaApp" target="_blank" rel="external">https://github.com/jiang111/RxJavaApp</a></p>
<h3 id="常用模板代码">常用模板代码</h3><p><a href="https://github.com/jiang111/awesome-android-tips" target="_blank" rel="external">https://github.com/jiang111/awesome-android-tips</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/23/Android逆向分析总结/" itemprop="url">
                Android逆向分析总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-02-23T15:10:15+08:00" content="2016-02-23">
            2016-02-23
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/23/Android逆向分析总结/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/23/Android逆向分析总结/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="相关文章">相关文章</h3><p><strong>Android逆向分析(1) 反编译看看手Q口令红包的实现原理</strong></p>
<p><a href="http://blog.zhaiyifan.cn/2016/02/09/android-reverse-1/" target="_blank" rel="external">http://blog.zhaiyifan.cn/2016/02/09/android-reverse-1/</a></p>
<p><strong>Android逆向分析(2) APK的打包与安装</strong></p>
<p><a href="http://blog.zhaiyifan.cn/2016/02/13/android-reverse-2/" target="_blank" rel="external">http://blog.zhaiyifan.cn/2016/02/13/android-reverse-2/</a></p>
<p><strong>编译时替换资源</strong></p>
<p><a href="http://blog.zhaiyifan.cn/2016/02/18/android-resource-overlay/" target="_blank" rel="external">http://blog.zhaiyifan.cn/2016/02/18/android-resource-overlay/</a></p>
<p><strong>Android逆向分析(3) Android可执行文件之谜 - DEX与ODEX, OAT与ELF</strong></p>
<p><a href="http://blog.zhaiyifan.cn/2016/02/24/android-reverse-3/" target="_blank" rel="external">http://blog.zhaiyifan.cn/2016/02/24/android-reverse-3/</a></p>
<p><strong>携程Android App插件化和动态加载实践</strong></p>
<p><a href="https://github.com/CtripMobile/DynamicAPK" target="_blank" rel="external">https://github.com/CtripMobile/DynamicAPK</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/18/反编译总结/" itemprop="url">
                反编译总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-02-18T14:20:40+08:00" content="2016-02-18">
            2016-02-18
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/18/反编译总结/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/18/反编译总结/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="反编译代码">反编译代码</h3><h4 id="工具">工具</h4><ul>
<li><p>dex2jar 用于将dex文件转换成jar文件</p>
<p>下载地址:<a href="http://sourceforge.net/projects/dex2jar/files/" target="_blank" rel="external">http://sourceforge.net/projects/dex2jar/files/</a></p>
</li>
<li><p>jd-gui 用于将jar文件转换成java代码</p>
<p>  下载地址：<a href="http://jd.benow.ca/" target="_blank" rel="external">http://jd.benow.ca/</a></p>
</li>
</ul>
<h4 id="操作步骤">操作步骤</h4><ul>
<li>将准备好的APK包解压，如果无法解压，可以将后缀换成.zip</li>
<li><p>将dex文件转换成jar文件</p>
<pre><code>./d2j-dex2jar<span class="class">.sh</span> qq.apk
</code></pre></li>
<li><p>使用jd-gui查看jar文件</p>
</li>
</ul>
<h3 id="反编译资源">反编译资源</h3><h4 id="工具-1">工具</h4><ul>
<li><p>apktool 用于还原APK文件中的9-patch图片，布局，字符串等资源</p>
<p>  下载地址：<a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="external">http://ibotpeaches.github.io/Apktool/install/</a></p>
</li>
</ul>
<h4 id="操作步骤-1">操作步骤</h4><pre><code><span class="tag">apktool</span> <span class="tag">d</span> <span class="tag">qq</span><span class="class">.apk</span>
</code></pre><p>d是decode的意思，以下是一些附加参数：</p>
<ul>
<li>-f 强制删除已经存在的文件夹</li>
<li>-o 指定文件夹的名称</li>
<li>-s 不反编译dex文件</li>
<li>-r 不反编译资源文件</li>
</ul>
<h3 id="重新打包">重新打包</h3><p><img src="http://img.blog.csdn.net/20160208234027946" alt="编译后的包目录"></p>
<ul>
<li>original 存放的是未经反编译过的原始清单文件</li>
<li>res 反编译后的资源文件</li>
<li><p>smali 反编译后的代码文件</p>
</li>
<li><p>打包APK</p>
<pre><code>apktool <span class="tag">b</span> apk文件夹 -o 打包后的APK名字
</code></pre></li>
<li><p>签名</p>
<pre><code><span class="title">jarsingner</span> -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore 签名文件名 -storepass 签名密码 待签名的APK文件名 签名的别名
</code></pre></li>
<li><p>对齐操作</p>
<pre><code>zipalign <span class="number">4</span> 待对齐APK文件名 对齐后的文件名
</code></pre></li>
</ul>
<h4 id="系统的混淆规则">系统的混淆规则</h4><ul>
<li>混淆还可以压缩代码，将没有用到的方法等都给移除掉</li>
<li>凡是需要在AndroidManifest.xml中注册的所有类的类名以及从负累重写的方法名都不会被混淆。</li>
<li><p>类中存在被native声明的方法，就不会被混淆         </p>
<h4 id="混淆jar包">混淆jar包</h4></li>
<li><p>第一步，将Class文件打成jar包</p>
<pre><code>jar -cvf androidTest<span class="class">.jar</span> -C app/buildintermediate/classes/debug
</code></pre></li>
<li><p>第二步，在<android sdk="">/tools/proguard/bin目录下能够看到如下文件</android></p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160310231053316" alt="打包工具"></p>
<ul>
<li>用<strong><em>sh proguardgui.sh</em></strong> 打开混淆工具</li>
</ul>
<h3 id="参考文章">参考文章</h3><p><a href="http://blog.csdn.net/guolin_blog/article/details/49738023" target="_blank" rel="external">郭霖-Android安全攻防战，反编译与混淆技术完全解析(上)</a></p>
<p><a href="http://www.mak-blog.com/tencent-shell-crack.html" target="_blank" rel="external">腾讯应用加固的脱壳分析和修复</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/50451259" target="_blank" rel="external">Android混淆技术</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/25/RxAndroid-第一部分/" itemprop="url">
                RxAndroid 第一部分
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-25T10:56:07+08:00" content="2016-01-25">
            2016-01-25
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/25/RxAndroid-第一部分/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/RxAndroid-第一部分/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>原文地址:<a href="https://medium.com/crunching-rxandroid/crunching-rxandroid-part-1-4ac7b7123238#.vo9v1p16d" target="_blank" rel="external">https://medium.com/crunching-rxandroid/crunching-rxandroid-part-1-4ac7b7123238#.vo9v1p16d</a></p>
<p>在上一篇文章中我们了解了一些基本的Rxjava的东西，接下来我们准备更深入一点。</p>
<p>首先，我们今天的主要目的就是当我们已经更多的了解了上篇文章的内容之后就开始缩短代码，让我们开始创建一些东西并且只把输入作为TextView的一个文本：</p>
<pre><code>Action1&lt;<span class="built_in">String</span>&gt; textViewOnNextAction = <span class="keyword">new</span> Action1&lt;<span class="built_in">String</span>&gt;(){
    <span class="annotation">@Override</span>
    public <span class="keyword">void</span> call(<span class="built_in">String</span> s){
        txtPart1.setText(s);
    }
}
</code></pre><p>分析上面的代码，我们可以意识到我们并没有创建一个完整的并且合格的订阅者。我们只实现了当成功的时候将会发生的一些事情，避免了与其他事件相关的我们不需要的代码。</p>
<p>有时候我们并不仅仅想为某个View设置一个标签，我们真正需要的是将字符串转换成大写的，因为我们想向全世界呼喊，我们可以使用一个函数，或多或少如下面这样</p>
<pre><code>Func1&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; toUpperCaseMap = new Func1&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;(){
    <span class="constant">@Override</span>
    public <span class="built_in">String</span> <span class="built_in">call</span>(){
        <span class="keyword">return</span> s.toUpperCase()<span class="comment">;</span>
    }
}
</code></pre><p>这时候我们就只需要创建一个新的Observable并且关联所有的逻辑，我们一次只需要发送一个单独的字符串，我们可以使用一个快捷健创建一个可观察到的静态的方法。</p>
<pre><code><span class="typename">Observable</span>&lt;String&gt; singleObservable = <span class="typename">Observable</span>.just(<span class="string">"Hello,World!"</span>);
</code></pre><p>现在我们需要将观察者,方法和订阅者串联起来，我们将会看到下面这些：</p>
<pre><code><span class="tag">singleObservable</span><span class="class">.observableOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>())
    <span class="class">.map</span>(<span class="tag">toUpperCaseMap</span>)
    <span class="class">.subscribe</span>(<span class="tag">textViewOnNextAction</span>);
</code></pre><p>你能察觉到这里的新闻吗，我说的就是<strong>map</strong>操作符。</p>
<h3 id="操作符">操作符</h3><p>再这个例子中，我们说明了第一个操作符，在这个特殊的例子中，一个从字符串到字符串的方法将使我们可以再将他传递给最终的订阅者之前对从观察者的任务进行计算。RxJava提供了许多不同的操作符，我们可以使用他来将任何东西转换成我们需要的数据。</p>
<h3 id="使用数组和集合">使用数组和集合</h3><p>我们看到了如何发射一个单独的条目，但是当我们想处理一组条目，并且一个接一个的发射他们该怎么做？我们从最简单的情况开始，我们想使用一个字符串数组并且将他们用Toast打印出来。</p>
<p>让我们定义一个订阅者只是用来对任意输出的字符串进行输出，所以我们必须在队列结束时运行：</p>
<pre><code>Action1&lt;<span class="built_in">String</span>&gt; toastOnNextAction = <span class="keyword">new</span> Action1&lt;<span class="built_in">String</span>&gt;(){
    <span class="annotation">@Override</span>
    public <span class="keyword">void</span> call(<span class="built_in">String</span> s){
        Toast.makeText(context,s,);
    }
}
</code></pre><p>正如我们看到的一样，这里没有什么新的东西，所以我们可以跳过直接去创建可观察对象，和我们之前例子中所做的一样，但是这里我们可以使用数组来一个接一个的发送条目。</p>
<pre><code><span class="typename">Observable</span>&lt;String&gt; oneByOneObservable = <span class="typename">Observable</span>.from(manyWords);
</code></pre><p>使用<strong>from()</strong>方法我们可以按顺序发送数组中的左右条目，我们不会太多的关系是怎么通过他们循环的，太棒了！</p>
<p>让我们接下来面对一个更复杂一点的例子，我们需要在一次单独的发射中一次发射一个完整的集合,然后处理每一个元素，首先，我们需要发射整个集合，从第一个例子中我们知道该怎么做，从工厂方法中创建一个单独的Observable:</p>
<pre><code><span class="tag">Observable</span><span class="class">.just</span>(<span class="tag">manyWordList</span>);
</code></pre><p>然后我们需要一个可观察的东西来返回另一个可观察的东西，或许我们需要一个操作符</p>
<h3 id="介绍flatMap">介绍flatMap</h3><p>我们看到map操作符可以将一些东西转换成另一些东西，但这不是他唯一能派上用场的地方，在这个例子中我们可以将一个Observable转换成另一个Observable，实现起来非常简单，我们可以再眨眼之间就能看到结果</p>
<pre><code>Func1&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;,Observable&lt;<span class="built_in">String</span>&gt;&gt; getUrls = <span class="keyword">new</span> Func1&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;,Observable&lt;<span class="built_in">String</span>&gt;&gt;(){
    <span class="annotation">@Override</span>
    public Observable&lt;<span class="built_in">String</span>&gt; call(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strings){
        <span class="keyword">return</span> Observable.from(strings);
    }
}
</code></pre><p>现在我们希望显示一个良好的格式化后的消息，我们可以使用<strong>reduce</strong>运算符,一旦Observable完成大蛇，他将会把获取到的字符串当作一个方法的输入进行合并</p>
<pre><code>Func2&lt;<span class="built_in">String</span>,<span class="built_in">String</span>,<span class="built_in">String</span>&gt; mergeRoutine = new Func2&lt;<span class="built_in">String</span>,<span class="built_in">String</span>,<span class="built_in">String</span>&gt;(){
    <span class="constant">@Override</span>
    public <span class="built_in">String</span> <span class="built_in">call</span>(<span class="built_in">String</span> s,<span class="built_in">String</span> s1){
        <span class="keyword">return</span> <span class="built_in">String</span>.format(<span class="string">"%s, %s"</span>,s,s1)<span class="comment">;</span>
    }
}
</code></pre><p>最后我们将所有的东西都连接起来，看看会看到什么神奇的事情发生！</p>
<pre><code><span class="tag">Observable</span><span class="class">.just</span>(<span class="tag">manyWordList</span>)
    <span class="class">.observableOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>())
    <span class="class">.flatMap</span>(<span class="tag">getUrls</span>)
    <span class="class">.reduce</span>(<span class="tag">mergeRoutine</span>)
    <span class="class">.subscribe</span>(<span class="tag">toastOnNextAction</span>);
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/25/RxAndroid介绍/" itemprop="url">
                RxAndroid介绍
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-25T09:29:36+08:00" content="2016-01-25">
            2016-01-25
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/25/RxAndroid介绍/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/RxAndroid介绍/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>原文地址:<a href="https://medium.com/crunching-rxandroid/crunching-rxandroid-intro-c27eb6f009ea#.4ailarz9d" target="_blank" rel="external">https://medium.com/crunching-rxandroid/crunching-rxandroid-intro-c27eb6f009ea#.4ailarz9d</a></p>
<p>几个月之前，我阅读了一系列神奇的文章，一段时间之后，我决定自己尝试一下这个库，并且从中分享一下我每天所获得的知识。</p>
<h3 id="现在让我们开始吧">现在让我们开始吧</h3><p>首先，我们需要创建一个新的Android项目，添加RxAndroid的依赖到build脚本中</p>
<pre><code><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:0.24.0'</span>
</code></pre><p>如果你想跳过这些初始化的部分，可以随时从GitHub上下载基本的项目。</p>
<h3 id="鼓捣代码">鼓捣代码</h3><p>乍一看， 响应式编程可能非常棘手，但是过一段时间之后你就会看到你的代码所产生的魔力，让我们现在开始深入代码吧！</p>
<p>这篇文章，我们将面临两个相关的组件，<strong>Observables</strong>和<strong>Subscribers</strong>,</p>
<p>刚开始的主要思想就是有一个可观测的发射字符串<strong><em>Hello,World</em></strong>并且终止执行。</p>
<pre><code>Observable.OnSubscribe observableAction = <span class="keyword">new</span> Observable.OnSubscribe&lt;<span class="keyword">String</span>&gt;(){
    <span class="keyword">public</span> <span class="keyword">void</span> call(Subscriber&lt;? <span class="keyword">super</span> <span class="keyword">String</span>&gt; subscriber){
        subscriber.onNext(<span class="string">"Hello,World!"</span>);
        subscriber.onCompleted();
    }
};
Observable&lt;<span class="keyword">String</span>&gt; observable = Observable.create(observableAction);
</code></pre><p>下一步就是创建两个订阅者，其中一个将收到的字符串作为参数设置给TextView，另外一个将直接通过Toast打印出来。</p>
<pre><code>Subscriber&lt;String&gt; textViewSubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;(){
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>{}
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span></span>{}
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span></span>{
        txtParta.setText(s);
    }
}

Subscriber&lt;String&gt; toastSubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;(){
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>{}
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span></span>{}
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span></span>{
        Toast.makeText(context,s,Toast.LENGTH_SHORT).show();
    }
}
</code></pre><p>最后，我们需要连接这些逻辑，我们需要使用Observable在主线程返回值，并且为他添加订阅者，这样在需要的时候就可以发射对象(这意味着被观察)。</p>
<p>选择适当的线程</p>
<pre><code><span class="tag">observable</span><span class="class">.observableOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>());
<span class="tag">observable</span><span class="class">.subscribe</span>(<span class="tag">textViewSubscriber</span>);
<span class="tag">observable</span><span class="class">.subscribe</span>(<span class="tag">toastSubscriber</span>);
</code></pre><p>如果你想更深入的了解这些代码，你可以从该<a href="https://github.com/tiwiz/RxAndroidCrunch/releases/tag/Part1" target="_blank" rel="external">链接</a>下载压缩包或者<a href="https://github.com/tiwiz/RxAndroidCrunch/" target="_blank" rel="external">克隆项目</a>，将会有新的发现。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/19/减小图片内存的方法/" itemprop="url">
                减小图片内存的方法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-19T11:59:56+08:00" content="2016-01-19">
            2016-01-19
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/19/减小图片内存的方法/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/19/减小图片内存的方法/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><strong>大图小用用采样，小图大用用矩阵</strong></p>
<h3 id="采样">采样</h3><pre><code>BitmapFactory.<span class="keyword">Options</span> <span class="keyword">options</span> = <span class="keyword">new</span> <span class="keyword">Options</span>();
<span class="keyword">options</span>.inSampleSize = <span class="number">2</span>;
Bitmap bitmap = BitmapFactory.decodeResource(getResources(),resId,<span class="keyword">options</span>);
</code></pre><h3 id="使用矩阵">使用矩阵</h3><p>方式一:</p>
<pre><code>Matrix matrix = <span class="keyword">new</span> Matrix();
matrix.preScale(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0f</span>,<span class="number">0f</span>);
<span class="comment">//如果使用直接替换矩阵的话，在Nexus6 5.1.1上必须关闭硬件加速</span>
canvas.concat(matrix);
canvas.drawBitmap(bitmap,<span class="number">0</span>,<span class="number">0</span>,paint);
</code></pre><p>方式二:</p>
<pre><code>Matrix matrix = <span class="keyword">new</span> Matrix();
matrix.preScale(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>);
canvas.drawBitmap(bitmap,matrix,paint);
</code></pre><p>这样绘制出来的图就是放大以后的效果了，不过占用的内存却依然是采样出来的大小。</p>
<pre><code>Matrix matrix = new Matrix()<span class="comment">;</span>
matrix.postScale(<span class="number">2,2,0,0</span>)<span class="comment">;</span>
imageView.setImageMatrix(matrix)<span class="comment">;</span>
imageView.setScaleType(ScaleType.MATRIX)<span class="comment">;</span>
imageView.setImageBitmap(bitmap)<span class="comment">;</span>
</code></pre><h3 id="选择Bitmap的像素格式">选择Bitmap的像素格式</h3><ul>
<li><p>ALPHA_8:只有一个alpha通道</p>
</li>
<li><p>ARGB_4444:不建议使用</p>
</li>
<li><p>ARGB_8888:ARGB四个通道，每个通道8Bit，是最常用的</p>
</li>
<li><p>RGB_565:每个像素占2Byte,当资源为jpg格式的情况下，用这个格式比较理想</p>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/11/使用RxJava控件缓存数据/" itemprop="url">
                使用RxJava控件缓存数据
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-11T11:41:28+08:00" content="2016-01-11">
            2016-01-11
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/11/使用RxJava控件缓存数据/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/11/使用RxJava控件缓存数据/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://img4.duitang.com/uploads/item/201405/07/20140507210553_NQGUP.thumb.600_0.jpeg" alt="坚持远方" itemprop="image"/>
          <p class="site-author-name" itemprop="name">坚持远方</p>
        </div>
        <p class="site-description motion-element" itemprop="description">既然选择远方，便只顾风雨兼程</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">34</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhanfangzxc" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5497967279" target="_blank">Weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵珊珊</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhaoshanshan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
